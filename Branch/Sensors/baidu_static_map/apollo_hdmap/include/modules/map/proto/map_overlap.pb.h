// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: modules/map/proto/map_overlap.proto

#ifndef PROTOBUF_modules_2fmap_2fproto_2fmap_5foverlap_2eproto__INCLUDED
#define PROTOBUF_modules_2fmap_2fproto_2fmap_5foverlap_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
#include "modules/map/proto/map_id.pb.h"
#include "modules/map/proto/map_geometry.pb.h"
// @@protoc_insertion_point(includes)

namespace apollo {
namespace hdmap {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
void protobuf_AssignDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
void protobuf_ShutdownFile_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();

class ClearAreaOverlapInfo;
class CrosswalkOverlapInfo;
class JunctionOverlapInfo;
class LaneOverlapInfo;
class ObjectOverlapInfo;
class Overlap;
class PNCJunctionOverlapInfo;
class ParkingSpaceOverlapInfo;
class RegionOverlapInfo;
class SignalOverlapInfo;
class SpeedBumpOverlapInfo;
class StopSignOverlapInfo;
class YieldOverlapInfo;

// ===================================================================

class LaneOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.LaneOverlapInfo) */ {
 public:
  LaneOverlapInfo();
  virtual ~LaneOverlapInfo();

  LaneOverlapInfo(const LaneOverlapInfo& from);

  inline LaneOverlapInfo& operator=(const LaneOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LaneOverlapInfo& default_instance();

  void Swap(LaneOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline LaneOverlapInfo* New() const { return New(NULL); }

  LaneOverlapInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LaneOverlapInfo& from);
  void MergeFrom(const LaneOverlapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(LaneOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double start_s = 1;
  bool has_start_s() const;
  void clear_start_s();
  static const int kStartSFieldNumber = 1;
  double start_s() const;
  void set_start_s(double value);

  // optional double end_s = 2;
  bool has_end_s() const;
  void clear_end_s();
  static const int kEndSFieldNumber = 2;
  double end_s() const;
  void set_end_s(double value);

  // optional bool is_merge = 3;
  bool has_is_merge() const;
  void clear_is_merge();
  static const int kIsMergeFieldNumber = 3;
  bool is_merge() const;
  void set_is_merge(bool value);

  // optional .apollo.hdmap.Id region_overlap_id = 4;
  bool has_region_overlap_id() const;
  void clear_region_overlap_id();
  static const int kRegionOverlapIdFieldNumber = 4;
  const ::apollo::hdmap::Id& region_overlap_id() const;
  ::apollo::hdmap::Id* mutable_region_overlap_id();
  ::apollo::hdmap::Id* release_region_overlap_id();
  void set_allocated_region_overlap_id(::apollo::hdmap::Id* region_overlap_id);

  // @@protoc_insertion_point(class_scope:apollo.hdmap.LaneOverlapInfo)
 private:
  inline void set_has_start_s();
  inline void clear_has_start_s();
  inline void set_has_end_s();
  inline void clear_has_end_s();
  inline void set_has_is_merge();
  inline void clear_has_is_merge();
  inline void set_has_region_overlap_id();
  inline void clear_has_region_overlap_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  double start_s_;
  double end_s_;
  ::apollo::hdmap::Id* region_overlap_id_;
  bool is_merge_;
  friend void  protobuf_AddDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_AssignDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_ShutdownFile_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();

  void InitAsDefaultInstance();
  static LaneOverlapInfo* default_instance_;
};
// -------------------------------------------------------------------

class SignalOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.SignalOverlapInfo) */ {
 public:
  SignalOverlapInfo();
  virtual ~SignalOverlapInfo();

  SignalOverlapInfo(const SignalOverlapInfo& from);

  inline SignalOverlapInfo& operator=(const SignalOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SignalOverlapInfo& default_instance();

  void Swap(SignalOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline SignalOverlapInfo* New() const { return New(NULL); }

  SignalOverlapInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SignalOverlapInfo& from);
  void MergeFrom(const SignalOverlapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SignalOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.SignalOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_AssignDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_ShutdownFile_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();

  void InitAsDefaultInstance();
  static SignalOverlapInfo* default_instance_;
};
// -------------------------------------------------------------------

class StopSignOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.StopSignOverlapInfo) */ {
 public:
  StopSignOverlapInfo();
  virtual ~StopSignOverlapInfo();

  StopSignOverlapInfo(const StopSignOverlapInfo& from);

  inline StopSignOverlapInfo& operator=(const StopSignOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StopSignOverlapInfo& default_instance();

  void Swap(StopSignOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline StopSignOverlapInfo* New() const { return New(NULL); }

  StopSignOverlapInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StopSignOverlapInfo& from);
  void MergeFrom(const StopSignOverlapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StopSignOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.StopSignOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_AssignDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_ShutdownFile_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();

  void InitAsDefaultInstance();
  static StopSignOverlapInfo* default_instance_;
};
// -------------------------------------------------------------------

class CrosswalkOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.CrosswalkOverlapInfo) */ {
 public:
  CrosswalkOverlapInfo();
  virtual ~CrosswalkOverlapInfo();

  CrosswalkOverlapInfo(const CrosswalkOverlapInfo& from);

  inline CrosswalkOverlapInfo& operator=(const CrosswalkOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrosswalkOverlapInfo& default_instance();

  void Swap(CrosswalkOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline CrosswalkOverlapInfo* New() const { return New(NULL); }

  CrosswalkOverlapInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CrosswalkOverlapInfo& from);
  void MergeFrom(const CrosswalkOverlapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CrosswalkOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.hdmap.Id region_overlap_id = 1;
  bool has_region_overlap_id() const;
  void clear_region_overlap_id();
  static const int kRegionOverlapIdFieldNumber = 1;
  const ::apollo::hdmap::Id& region_overlap_id() const;
  ::apollo::hdmap::Id* mutable_region_overlap_id();
  ::apollo::hdmap::Id* release_region_overlap_id();
  void set_allocated_region_overlap_id(::apollo::hdmap::Id* region_overlap_id);

  // @@protoc_insertion_point(class_scope:apollo.hdmap.CrosswalkOverlapInfo)
 private:
  inline void set_has_region_overlap_id();
  inline void clear_has_region_overlap_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::apollo::hdmap::Id* region_overlap_id_;
  friend void  protobuf_AddDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_AssignDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_ShutdownFile_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();

  void InitAsDefaultInstance();
  static CrosswalkOverlapInfo* default_instance_;
};
// -------------------------------------------------------------------

class JunctionOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.JunctionOverlapInfo) */ {
 public:
  JunctionOverlapInfo();
  virtual ~JunctionOverlapInfo();

  JunctionOverlapInfo(const JunctionOverlapInfo& from);

  inline JunctionOverlapInfo& operator=(const JunctionOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const JunctionOverlapInfo& default_instance();

  void Swap(JunctionOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline JunctionOverlapInfo* New() const { return New(NULL); }

  JunctionOverlapInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const JunctionOverlapInfo& from);
  void MergeFrom(const JunctionOverlapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(JunctionOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.JunctionOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_AssignDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_ShutdownFile_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();

  void InitAsDefaultInstance();
  static JunctionOverlapInfo* default_instance_;
};
// -------------------------------------------------------------------

class YieldOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.YieldOverlapInfo) */ {
 public:
  YieldOverlapInfo();
  virtual ~YieldOverlapInfo();

  YieldOverlapInfo(const YieldOverlapInfo& from);

  inline YieldOverlapInfo& operator=(const YieldOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const YieldOverlapInfo& default_instance();

  void Swap(YieldOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline YieldOverlapInfo* New() const { return New(NULL); }

  YieldOverlapInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const YieldOverlapInfo& from);
  void MergeFrom(const YieldOverlapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(YieldOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.YieldOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_AssignDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_ShutdownFile_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();

  void InitAsDefaultInstance();
  static YieldOverlapInfo* default_instance_;
};
// -------------------------------------------------------------------

class ClearAreaOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.ClearAreaOverlapInfo) */ {
 public:
  ClearAreaOverlapInfo();
  virtual ~ClearAreaOverlapInfo();

  ClearAreaOverlapInfo(const ClearAreaOverlapInfo& from);

  inline ClearAreaOverlapInfo& operator=(const ClearAreaOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ClearAreaOverlapInfo& default_instance();

  void Swap(ClearAreaOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline ClearAreaOverlapInfo* New() const { return New(NULL); }

  ClearAreaOverlapInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ClearAreaOverlapInfo& from);
  void MergeFrom(const ClearAreaOverlapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClearAreaOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.ClearAreaOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_AssignDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_ShutdownFile_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();

  void InitAsDefaultInstance();
  static ClearAreaOverlapInfo* default_instance_;
};
// -------------------------------------------------------------------

class SpeedBumpOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.SpeedBumpOverlapInfo) */ {
 public:
  SpeedBumpOverlapInfo();
  virtual ~SpeedBumpOverlapInfo();

  SpeedBumpOverlapInfo(const SpeedBumpOverlapInfo& from);

  inline SpeedBumpOverlapInfo& operator=(const SpeedBumpOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeedBumpOverlapInfo& default_instance();

  void Swap(SpeedBumpOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline SpeedBumpOverlapInfo* New() const { return New(NULL); }

  SpeedBumpOverlapInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpeedBumpOverlapInfo& from);
  void MergeFrom(const SpeedBumpOverlapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SpeedBumpOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.SpeedBumpOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_AssignDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_ShutdownFile_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();

  void InitAsDefaultInstance();
  static SpeedBumpOverlapInfo* default_instance_;
};
// -------------------------------------------------------------------

class ParkingSpaceOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.ParkingSpaceOverlapInfo) */ {
 public:
  ParkingSpaceOverlapInfo();
  virtual ~ParkingSpaceOverlapInfo();

  ParkingSpaceOverlapInfo(const ParkingSpaceOverlapInfo& from);

  inline ParkingSpaceOverlapInfo& operator=(const ParkingSpaceOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ParkingSpaceOverlapInfo& default_instance();

  void Swap(ParkingSpaceOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline ParkingSpaceOverlapInfo* New() const { return New(NULL); }

  ParkingSpaceOverlapInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ParkingSpaceOverlapInfo& from);
  void MergeFrom(const ParkingSpaceOverlapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ParkingSpaceOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.ParkingSpaceOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_AssignDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_ShutdownFile_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();

  void InitAsDefaultInstance();
  static ParkingSpaceOverlapInfo* default_instance_;
};
// -------------------------------------------------------------------

class PNCJunctionOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.PNCJunctionOverlapInfo) */ {
 public:
  PNCJunctionOverlapInfo();
  virtual ~PNCJunctionOverlapInfo();

  PNCJunctionOverlapInfo(const PNCJunctionOverlapInfo& from);

  inline PNCJunctionOverlapInfo& operator=(const PNCJunctionOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PNCJunctionOverlapInfo& default_instance();

  void Swap(PNCJunctionOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline PNCJunctionOverlapInfo* New() const { return New(NULL); }

  PNCJunctionOverlapInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PNCJunctionOverlapInfo& from);
  void MergeFrom(const PNCJunctionOverlapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PNCJunctionOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:apollo.hdmap.PNCJunctionOverlapInfo)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_AssignDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_ShutdownFile_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();

  void InitAsDefaultInstance();
  static PNCJunctionOverlapInfo* default_instance_;
};
// -------------------------------------------------------------------

class RegionOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.RegionOverlapInfo) */ {
 public:
  RegionOverlapInfo();
  virtual ~RegionOverlapInfo();

  RegionOverlapInfo(const RegionOverlapInfo& from);

  inline RegionOverlapInfo& operator=(const RegionOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RegionOverlapInfo& default_instance();

  void Swap(RegionOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline RegionOverlapInfo* New() const { return New(NULL); }

  RegionOverlapInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RegionOverlapInfo& from);
  void MergeFrom(const RegionOverlapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(RegionOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.hdmap.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::apollo::hdmap::Id& id() const;
  ::apollo::hdmap::Id* mutable_id();
  ::apollo::hdmap::Id* release_id();
  void set_allocated_id(::apollo::hdmap::Id* id);

  // repeated .apollo.hdmap.Polygon polygon = 2;
  int polygon_size() const;
  void clear_polygon();
  static const int kPolygonFieldNumber = 2;
  const ::apollo::hdmap::Polygon& polygon(int index) const;
  ::apollo::hdmap::Polygon* mutable_polygon(int index);
  ::apollo::hdmap::Polygon* add_polygon();
  ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::Polygon >*
      mutable_polygon();
  const ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::Polygon >&
      polygon() const;

  // @@protoc_insertion_point(class_scope:apollo.hdmap.RegionOverlapInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::apollo::hdmap::Id* id_;
  ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::Polygon > polygon_;
  friend void  protobuf_AddDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_AssignDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_ShutdownFile_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();

  void InitAsDefaultInstance();
  static RegionOverlapInfo* default_instance_;
};
// -------------------------------------------------------------------

class ObjectOverlapInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.ObjectOverlapInfo) */ {
 public:
  ObjectOverlapInfo();
  virtual ~ObjectOverlapInfo();

  ObjectOverlapInfo(const ObjectOverlapInfo& from);

  inline ObjectOverlapInfo& operator=(const ObjectOverlapInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectOverlapInfo& default_instance();

  enum OverlapInfoCase {
    kLaneOverlapInfo = 3,
    kSignalOverlapInfo = 4,
    kStopSignOverlapInfo = 5,
    kCrosswalkOverlapInfo = 6,
    kJunctionOverlapInfo = 7,
    kYieldSignOverlapInfo = 8,
    kClearAreaOverlapInfo = 9,
    kSpeedBumpOverlapInfo = 10,
    kParkingSpaceOverlapInfo = 11,
    kPncJunctionOverlapInfo = 12,
    OVERLAP_INFO_NOT_SET = 0,
  };

  void Swap(ObjectOverlapInfo* other);

  // implements Message ----------------------------------------------

  inline ObjectOverlapInfo* New() const { return New(NULL); }

  ObjectOverlapInfo* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectOverlapInfo& from);
  void MergeFrom(const ObjectOverlapInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ObjectOverlapInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.hdmap.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::apollo::hdmap::Id& id() const;
  ::apollo::hdmap::Id* mutable_id();
  ::apollo::hdmap::Id* release_id();
  void set_allocated_id(::apollo::hdmap::Id* id);

  // optional .apollo.hdmap.LaneOverlapInfo lane_overlap_info = 3;
  bool has_lane_overlap_info() const;
  void clear_lane_overlap_info();
  static const int kLaneOverlapInfoFieldNumber = 3;
  const ::apollo::hdmap::LaneOverlapInfo& lane_overlap_info() const;
  ::apollo::hdmap::LaneOverlapInfo* mutable_lane_overlap_info();
  ::apollo::hdmap::LaneOverlapInfo* release_lane_overlap_info();
  void set_allocated_lane_overlap_info(::apollo::hdmap::LaneOverlapInfo* lane_overlap_info);

  // optional .apollo.hdmap.SignalOverlapInfo signal_overlap_info = 4;
  bool has_signal_overlap_info() const;
  void clear_signal_overlap_info();
  static const int kSignalOverlapInfoFieldNumber = 4;
  const ::apollo::hdmap::SignalOverlapInfo& signal_overlap_info() const;
  ::apollo::hdmap::SignalOverlapInfo* mutable_signal_overlap_info();
  ::apollo::hdmap::SignalOverlapInfo* release_signal_overlap_info();
  void set_allocated_signal_overlap_info(::apollo::hdmap::SignalOverlapInfo* signal_overlap_info);

  // optional .apollo.hdmap.StopSignOverlapInfo stop_sign_overlap_info = 5;
  bool has_stop_sign_overlap_info() const;
  void clear_stop_sign_overlap_info();
  static const int kStopSignOverlapInfoFieldNumber = 5;
  const ::apollo::hdmap::StopSignOverlapInfo& stop_sign_overlap_info() const;
  ::apollo::hdmap::StopSignOverlapInfo* mutable_stop_sign_overlap_info();
  ::apollo::hdmap::StopSignOverlapInfo* release_stop_sign_overlap_info();
  void set_allocated_stop_sign_overlap_info(::apollo::hdmap::StopSignOverlapInfo* stop_sign_overlap_info);

  // optional .apollo.hdmap.CrosswalkOverlapInfo crosswalk_overlap_info = 6;
  bool has_crosswalk_overlap_info() const;
  void clear_crosswalk_overlap_info();
  static const int kCrosswalkOverlapInfoFieldNumber = 6;
  const ::apollo::hdmap::CrosswalkOverlapInfo& crosswalk_overlap_info() const;
  ::apollo::hdmap::CrosswalkOverlapInfo* mutable_crosswalk_overlap_info();
  ::apollo::hdmap::CrosswalkOverlapInfo* release_crosswalk_overlap_info();
  void set_allocated_crosswalk_overlap_info(::apollo::hdmap::CrosswalkOverlapInfo* crosswalk_overlap_info);

  // optional .apollo.hdmap.JunctionOverlapInfo junction_overlap_info = 7;
  bool has_junction_overlap_info() const;
  void clear_junction_overlap_info();
  static const int kJunctionOverlapInfoFieldNumber = 7;
  const ::apollo::hdmap::JunctionOverlapInfo& junction_overlap_info() const;
  ::apollo::hdmap::JunctionOverlapInfo* mutable_junction_overlap_info();
  ::apollo::hdmap::JunctionOverlapInfo* release_junction_overlap_info();
  void set_allocated_junction_overlap_info(::apollo::hdmap::JunctionOverlapInfo* junction_overlap_info);

  // optional .apollo.hdmap.YieldOverlapInfo yield_sign_overlap_info = 8;
  bool has_yield_sign_overlap_info() const;
  void clear_yield_sign_overlap_info();
  static const int kYieldSignOverlapInfoFieldNumber = 8;
  const ::apollo::hdmap::YieldOverlapInfo& yield_sign_overlap_info() const;
  ::apollo::hdmap::YieldOverlapInfo* mutable_yield_sign_overlap_info();
  ::apollo::hdmap::YieldOverlapInfo* release_yield_sign_overlap_info();
  void set_allocated_yield_sign_overlap_info(::apollo::hdmap::YieldOverlapInfo* yield_sign_overlap_info);

  // optional .apollo.hdmap.ClearAreaOverlapInfo clear_area_overlap_info = 9;
  bool has_clear_area_overlap_info() const;
  void clear_clear_area_overlap_info();
  static const int kClearAreaOverlapInfoFieldNumber = 9;
  const ::apollo::hdmap::ClearAreaOverlapInfo& clear_area_overlap_info() const;
  ::apollo::hdmap::ClearAreaOverlapInfo* mutable_clear_area_overlap_info();
  ::apollo::hdmap::ClearAreaOverlapInfo* release_clear_area_overlap_info();
  void set_allocated_clear_area_overlap_info(::apollo::hdmap::ClearAreaOverlapInfo* clear_area_overlap_info);

  // optional .apollo.hdmap.SpeedBumpOverlapInfo speed_bump_overlap_info = 10;
  bool has_speed_bump_overlap_info() const;
  void clear_speed_bump_overlap_info();
  static const int kSpeedBumpOverlapInfoFieldNumber = 10;
  const ::apollo::hdmap::SpeedBumpOverlapInfo& speed_bump_overlap_info() const;
  ::apollo::hdmap::SpeedBumpOverlapInfo* mutable_speed_bump_overlap_info();
  ::apollo::hdmap::SpeedBumpOverlapInfo* release_speed_bump_overlap_info();
  void set_allocated_speed_bump_overlap_info(::apollo::hdmap::SpeedBumpOverlapInfo* speed_bump_overlap_info);

  // optional .apollo.hdmap.ParkingSpaceOverlapInfo parking_space_overlap_info = 11;
  bool has_parking_space_overlap_info() const;
  void clear_parking_space_overlap_info();
  static const int kParkingSpaceOverlapInfoFieldNumber = 11;
  const ::apollo::hdmap::ParkingSpaceOverlapInfo& parking_space_overlap_info() const;
  ::apollo::hdmap::ParkingSpaceOverlapInfo* mutable_parking_space_overlap_info();
  ::apollo::hdmap::ParkingSpaceOverlapInfo* release_parking_space_overlap_info();
  void set_allocated_parking_space_overlap_info(::apollo::hdmap::ParkingSpaceOverlapInfo* parking_space_overlap_info);

  // optional .apollo.hdmap.PNCJunctionOverlapInfo pnc_junction_overlap_info = 12;
  bool has_pnc_junction_overlap_info() const;
  void clear_pnc_junction_overlap_info();
  static const int kPncJunctionOverlapInfoFieldNumber = 12;
  const ::apollo::hdmap::PNCJunctionOverlapInfo& pnc_junction_overlap_info() const;
  ::apollo::hdmap::PNCJunctionOverlapInfo* mutable_pnc_junction_overlap_info();
  ::apollo::hdmap::PNCJunctionOverlapInfo* release_pnc_junction_overlap_info();
  void set_allocated_pnc_junction_overlap_info(::apollo::hdmap::PNCJunctionOverlapInfo* pnc_junction_overlap_info);

  OverlapInfoCase overlap_info_case() const;
  // @@protoc_insertion_point(class_scope:apollo.hdmap.ObjectOverlapInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_lane_overlap_info();
  inline void set_has_signal_overlap_info();
  inline void set_has_stop_sign_overlap_info();
  inline void set_has_crosswalk_overlap_info();
  inline void set_has_junction_overlap_info();
  inline void set_has_yield_sign_overlap_info();
  inline void set_has_clear_area_overlap_info();
  inline void set_has_speed_bump_overlap_info();
  inline void set_has_parking_space_overlap_info();
  inline void set_has_pnc_junction_overlap_info();

  inline bool has_overlap_info() const;
  void clear_overlap_info();
  inline void clear_has_overlap_info();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::apollo::hdmap::Id* id_;
  union OverlapInfoUnion {
    OverlapInfoUnion() {}
    ::apollo::hdmap::LaneOverlapInfo* lane_overlap_info_;
    ::apollo::hdmap::SignalOverlapInfo* signal_overlap_info_;
    ::apollo::hdmap::StopSignOverlapInfo* stop_sign_overlap_info_;
    ::apollo::hdmap::CrosswalkOverlapInfo* crosswalk_overlap_info_;
    ::apollo::hdmap::JunctionOverlapInfo* junction_overlap_info_;
    ::apollo::hdmap::YieldOverlapInfo* yield_sign_overlap_info_;
    ::apollo::hdmap::ClearAreaOverlapInfo* clear_area_overlap_info_;
    ::apollo::hdmap::SpeedBumpOverlapInfo* speed_bump_overlap_info_;
    ::apollo::hdmap::ParkingSpaceOverlapInfo* parking_space_overlap_info_;
    ::apollo::hdmap::PNCJunctionOverlapInfo* pnc_junction_overlap_info_;
  } overlap_info_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_AssignDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_ShutdownFile_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();

  void InitAsDefaultInstance();
  static ObjectOverlapInfo* default_instance_;
};
// -------------------------------------------------------------------

class Overlap : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:apollo.hdmap.Overlap) */ {
 public:
  Overlap();
  virtual ~Overlap();

  Overlap(const Overlap& from);

  inline Overlap& operator=(const Overlap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Overlap& default_instance();

  void Swap(Overlap* other);

  // implements Message ----------------------------------------------

  inline Overlap* New() const { return New(NULL); }

  Overlap* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Overlap& from);
  void MergeFrom(const Overlap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Overlap* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .apollo.hdmap.Id id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::apollo::hdmap::Id& id() const;
  ::apollo::hdmap::Id* mutable_id();
  ::apollo::hdmap::Id* release_id();
  void set_allocated_id(::apollo::hdmap::Id* id);

  // repeated .apollo.hdmap.ObjectOverlapInfo object = 2;
  int object_size() const;
  void clear_object();
  static const int kObjectFieldNumber = 2;
  const ::apollo::hdmap::ObjectOverlapInfo& object(int index) const;
  ::apollo::hdmap::ObjectOverlapInfo* mutable_object(int index);
  ::apollo::hdmap::ObjectOverlapInfo* add_object();
  ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::ObjectOverlapInfo >*
      mutable_object();
  const ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::ObjectOverlapInfo >&
      object() const;

  // repeated .apollo.hdmap.RegionOverlapInfo region_overlap = 3;
  int region_overlap_size() const;
  void clear_region_overlap();
  static const int kRegionOverlapFieldNumber = 3;
  const ::apollo::hdmap::RegionOverlapInfo& region_overlap(int index) const;
  ::apollo::hdmap::RegionOverlapInfo* mutable_region_overlap(int index);
  ::apollo::hdmap::RegionOverlapInfo* add_region_overlap();
  ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::RegionOverlapInfo >*
      mutable_region_overlap();
  const ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::RegionOverlapInfo >&
      region_overlap() const;

  // @@protoc_insertion_point(class_scope:apollo.hdmap.Overlap)
 private:
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::apollo::hdmap::Id* id_;
  ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::ObjectOverlapInfo > object_;
  ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::RegionOverlapInfo > region_overlap_;
  friend void  protobuf_AddDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_AssignDesc_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();
  friend void protobuf_ShutdownFile_modules_2fmap_2fproto_2fmap_5foverlap_2eproto();

  void InitAsDefaultInstance();
  static Overlap* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// LaneOverlapInfo

// optional double start_s = 1;
inline bool LaneOverlapInfo::has_start_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LaneOverlapInfo::set_has_start_s() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LaneOverlapInfo::clear_has_start_s() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LaneOverlapInfo::clear_start_s() {
  start_s_ = 0;
  clear_has_start_s();
}
inline double LaneOverlapInfo::start_s() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.LaneOverlapInfo.start_s)
  return start_s_;
}
inline void LaneOverlapInfo::set_start_s(double value) {
  set_has_start_s();
  start_s_ = value;
  // @@protoc_insertion_point(field_set:apollo.hdmap.LaneOverlapInfo.start_s)
}

// optional double end_s = 2;
inline bool LaneOverlapInfo::has_end_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LaneOverlapInfo::set_has_end_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LaneOverlapInfo::clear_has_end_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LaneOverlapInfo::clear_end_s() {
  end_s_ = 0;
  clear_has_end_s();
}
inline double LaneOverlapInfo::end_s() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.LaneOverlapInfo.end_s)
  return end_s_;
}
inline void LaneOverlapInfo::set_end_s(double value) {
  set_has_end_s();
  end_s_ = value;
  // @@protoc_insertion_point(field_set:apollo.hdmap.LaneOverlapInfo.end_s)
}

// optional bool is_merge = 3;
inline bool LaneOverlapInfo::has_is_merge() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LaneOverlapInfo::set_has_is_merge() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LaneOverlapInfo::clear_has_is_merge() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LaneOverlapInfo::clear_is_merge() {
  is_merge_ = false;
  clear_has_is_merge();
}
inline bool LaneOverlapInfo::is_merge() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.LaneOverlapInfo.is_merge)
  return is_merge_;
}
inline void LaneOverlapInfo::set_is_merge(bool value) {
  set_has_is_merge();
  is_merge_ = value;
  // @@protoc_insertion_point(field_set:apollo.hdmap.LaneOverlapInfo.is_merge)
}

// optional .apollo.hdmap.Id region_overlap_id = 4;
inline bool LaneOverlapInfo::has_region_overlap_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LaneOverlapInfo::set_has_region_overlap_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LaneOverlapInfo::clear_has_region_overlap_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LaneOverlapInfo::clear_region_overlap_id() {
  if (region_overlap_id_ != NULL) region_overlap_id_->::apollo::hdmap::Id::Clear();
  clear_has_region_overlap_id();
}
inline const ::apollo::hdmap::Id& LaneOverlapInfo::region_overlap_id() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.LaneOverlapInfo.region_overlap_id)
  return region_overlap_id_ != NULL ? *region_overlap_id_ : *default_instance_->region_overlap_id_;
}
inline ::apollo::hdmap::Id* LaneOverlapInfo::mutable_region_overlap_id() {
  set_has_region_overlap_id();
  if (region_overlap_id_ == NULL) {
    region_overlap_id_ = new ::apollo::hdmap::Id;
  }
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.LaneOverlapInfo.region_overlap_id)
  return region_overlap_id_;
}
inline ::apollo::hdmap::Id* LaneOverlapInfo::release_region_overlap_id() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.LaneOverlapInfo.region_overlap_id)
  clear_has_region_overlap_id();
  ::apollo::hdmap::Id* temp = region_overlap_id_;
  region_overlap_id_ = NULL;
  return temp;
}
inline void LaneOverlapInfo::set_allocated_region_overlap_id(::apollo::hdmap::Id* region_overlap_id) {
  delete region_overlap_id_;
  region_overlap_id_ = region_overlap_id;
  if (region_overlap_id) {
    set_has_region_overlap_id();
  } else {
    clear_has_region_overlap_id();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.LaneOverlapInfo.region_overlap_id)
}

// -------------------------------------------------------------------

// SignalOverlapInfo

// -------------------------------------------------------------------

// StopSignOverlapInfo

// -------------------------------------------------------------------

// CrosswalkOverlapInfo

// optional .apollo.hdmap.Id region_overlap_id = 1;
inline bool CrosswalkOverlapInfo::has_region_overlap_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrosswalkOverlapInfo::set_has_region_overlap_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrosswalkOverlapInfo::clear_has_region_overlap_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CrosswalkOverlapInfo::clear_region_overlap_id() {
  if (region_overlap_id_ != NULL) region_overlap_id_->::apollo::hdmap::Id::Clear();
  clear_has_region_overlap_id();
}
inline const ::apollo::hdmap::Id& CrosswalkOverlapInfo::region_overlap_id() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.CrosswalkOverlapInfo.region_overlap_id)
  return region_overlap_id_ != NULL ? *region_overlap_id_ : *default_instance_->region_overlap_id_;
}
inline ::apollo::hdmap::Id* CrosswalkOverlapInfo::mutable_region_overlap_id() {
  set_has_region_overlap_id();
  if (region_overlap_id_ == NULL) {
    region_overlap_id_ = new ::apollo::hdmap::Id;
  }
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.CrosswalkOverlapInfo.region_overlap_id)
  return region_overlap_id_;
}
inline ::apollo::hdmap::Id* CrosswalkOverlapInfo::release_region_overlap_id() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.CrosswalkOverlapInfo.region_overlap_id)
  clear_has_region_overlap_id();
  ::apollo::hdmap::Id* temp = region_overlap_id_;
  region_overlap_id_ = NULL;
  return temp;
}
inline void CrosswalkOverlapInfo::set_allocated_region_overlap_id(::apollo::hdmap::Id* region_overlap_id) {
  delete region_overlap_id_;
  region_overlap_id_ = region_overlap_id;
  if (region_overlap_id) {
    set_has_region_overlap_id();
  } else {
    clear_has_region_overlap_id();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.CrosswalkOverlapInfo.region_overlap_id)
}

// -------------------------------------------------------------------

// JunctionOverlapInfo

// -------------------------------------------------------------------

// YieldOverlapInfo

// -------------------------------------------------------------------

// ClearAreaOverlapInfo

// -------------------------------------------------------------------

// SpeedBumpOverlapInfo

// -------------------------------------------------------------------

// ParkingSpaceOverlapInfo

// -------------------------------------------------------------------

// PNCJunctionOverlapInfo

// -------------------------------------------------------------------

// RegionOverlapInfo

// optional .apollo.hdmap.Id id = 1;
inline bool RegionOverlapInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegionOverlapInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegionOverlapInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegionOverlapInfo::clear_id() {
  if (id_ != NULL) id_->::apollo::hdmap::Id::Clear();
  clear_has_id();
}
inline const ::apollo::hdmap::Id& RegionOverlapInfo::id() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.RegionOverlapInfo.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::apollo::hdmap::Id* RegionOverlapInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::apollo::hdmap::Id;
  }
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.RegionOverlapInfo.id)
  return id_;
}
inline ::apollo::hdmap::Id* RegionOverlapInfo::release_id() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.RegionOverlapInfo.id)
  clear_has_id();
  ::apollo::hdmap::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void RegionOverlapInfo::set_allocated_id(::apollo::hdmap::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.RegionOverlapInfo.id)
}

// repeated .apollo.hdmap.Polygon polygon = 2;
inline int RegionOverlapInfo::polygon_size() const {
  return polygon_.size();
}
inline void RegionOverlapInfo::clear_polygon() {
  polygon_.Clear();
}
inline const ::apollo::hdmap::Polygon& RegionOverlapInfo::polygon(int index) const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.RegionOverlapInfo.polygon)
  return polygon_.Get(index);
}
inline ::apollo::hdmap::Polygon* RegionOverlapInfo::mutable_polygon(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.RegionOverlapInfo.polygon)
  return polygon_.Mutable(index);
}
inline ::apollo::hdmap::Polygon* RegionOverlapInfo::add_polygon() {
  // @@protoc_insertion_point(field_add:apollo.hdmap.RegionOverlapInfo.polygon)
  return polygon_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::Polygon >*
RegionOverlapInfo::mutable_polygon() {
  // @@protoc_insertion_point(field_mutable_list:apollo.hdmap.RegionOverlapInfo.polygon)
  return &polygon_;
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::Polygon >&
RegionOverlapInfo::polygon() const {
  // @@protoc_insertion_point(field_list:apollo.hdmap.RegionOverlapInfo.polygon)
  return polygon_;
}

// -------------------------------------------------------------------

// ObjectOverlapInfo

// optional .apollo.hdmap.Id id = 1;
inline bool ObjectOverlapInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectOverlapInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectOverlapInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectOverlapInfo::clear_id() {
  if (id_ != NULL) id_->::apollo::hdmap::Id::Clear();
  clear_has_id();
}
inline const ::apollo::hdmap::Id& ObjectOverlapInfo::id() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::apollo::hdmap::Id* ObjectOverlapInfo::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::apollo::hdmap::Id;
  }
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.id)
  return id_;
}
inline ::apollo::hdmap::Id* ObjectOverlapInfo::release_id() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.id)
  clear_has_id();
  ::apollo::hdmap::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void ObjectOverlapInfo::set_allocated_id(::apollo::hdmap::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.id)
}

// optional .apollo.hdmap.LaneOverlapInfo lane_overlap_info = 3;
inline bool ObjectOverlapInfo::has_lane_overlap_info() const {
  return overlap_info_case() == kLaneOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_lane_overlap_info() {
  _oneof_case_[0] = kLaneOverlapInfo;
}
inline void ObjectOverlapInfo::clear_lane_overlap_info() {
  if (has_lane_overlap_info()) {
    delete overlap_info_.lane_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::apollo::hdmap::LaneOverlapInfo& ObjectOverlapInfo::lane_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.lane_overlap_info)
  return has_lane_overlap_info()
      ? *overlap_info_.lane_overlap_info_
      : ::apollo::hdmap::LaneOverlapInfo::default_instance();
}
inline ::apollo::hdmap::LaneOverlapInfo* ObjectOverlapInfo::mutable_lane_overlap_info() {
  if (!has_lane_overlap_info()) {
    clear_overlap_info();
    set_has_lane_overlap_info();
    overlap_info_.lane_overlap_info_ = new ::apollo::hdmap::LaneOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.lane_overlap_info)
  return overlap_info_.lane_overlap_info_;
}
inline ::apollo::hdmap::LaneOverlapInfo* ObjectOverlapInfo::release_lane_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.lane_overlap_info)
  if (has_lane_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::LaneOverlapInfo* temp = overlap_info_.lane_overlap_info_;
    overlap_info_.lane_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_lane_overlap_info(::apollo::hdmap::LaneOverlapInfo* lane_overlap_info) {
  clear_overlap_info();
  if (lane_overlap_info) {
    set_has_lane_overlap_info();
    overlap_info_.lane_overlap_info_ = lane_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.lane_overlap_info)
}

// optional .apollo.hdmap.SignalOverlapInfo signal_overlap_info = 4;
inline bool ObjectOverlapInfo::has_signal_overlap_info() const {
  return overlap_info_case() == kSignalOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_signal_overlap_info() {
  _oneof_case_[0] = kSignalOverlapInfo;
}
inline void ObjectOverlapInfo::clear_signal_overlap_info() {
  if (has_signal_overlap_info()) {
    delete overlap_info_.signal_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::apollo::hdmap::SignalOverlapInfo& ObjectOverlapInfo::signal_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.signal_overlap_info)
  return has_signal_overlap_info()
      ? *overlap_info_.signal_overlap_info_
      : ::apollo::hdmap::SignalOverlapInfo::default_instance();
}
inline ::apollo::hdmap::SignalOverlapInfo* ObjectOverlapInfo::mutable_signal_overlap_info() {
  if (!has_signal_overlap_info()) {
    clear_overlap_info();
    set_has_signal_overlap_info();
    overlap_info_.signal_overlap_info_ = new ::apollo::hdmap::SignalOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.signal_overlap_info)
  return overlap_info_.signal_overlap_info_;
}
inline ::apollo::hdmap::SignalOverlapInfo* ObjectOverlapInfo::release_signal_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.signal_overlap_info)
  if (has_signal_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::SignalOverlapInfo* temp = overlap_info_.signal_overlap_info_;
    overlap_info_.signal_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_signal_overlap_info(::apollo::hdmap::SignalOverlapInfo* signal_overlap_info) {
  clear_overlap_info();
  if (signal_overlap_info) {
    set_has_signal_overlap_info();
    overlap_info_.signal_overlap_info_ = signal_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.signal_overlap_info)
}

// optional .apollo.hdmap.StopSignOverlapInfo stop_sign_overlap_info = 5;
inline bool ObjectOverlapInfo::has_stop_sign_overlap_info() const {
  return overlap_info_case() == kStopSignOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_stop_sign_overlap_info() {
  _oneof_case_[0] = kStopSignOverlapInfo;
}
inline void ObjectOverlapInfo::clear_stop_sign_overlap_info() {
  if (has_stop_sign_overlap_info()) {
    delete overlap_info_.stop_sign_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::apollo::hdmap::StopSignOverlapInfo& ObjectOverlapInfo::stop_sign_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  return has_stop_sign_overlap_info()
      ? *overlap_info_.stop_sign_overlap_info_
      : ::apollo::hdmap::StopSignOverlapInfo::default_instance();
}
inline ::apollo::hdmap::StopSignOverlapInfo* ObjectOverlapInfo::mutable_stop_sign_overlap_info() {
  if (!has_stop_sign_overlap_info()) {
    clear_overlap_info();
    set_has_stop_sign_overlap_info();
    overlap_info_.stop_sign_overlap_info_ = new ::apollo::hdmap::StopSignOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  return overlap_info_.stop_sign_overlap_info_;
}
inline ::apollo::hdmap::StopSignOverlapInfo* ObjectOverlapInfo::release_stop_sign_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
  if (has_stop_sign_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::StopSignOverlapInfo* temp = overlap_info_.stop_sign_overlap_info_;
    overlap_info_.stop_sign_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_stop_sign_overlap_info(::apollo::hdmap::StopSignOverlapInfo* stop_sign_overlap_info) {
  clear_overlap_info();
  if (stop_sign_overlap_info) {
    set_has_stop_sign_overlap_info();
    overlap_info_.stop_sign_overlap_info_ = stop_sign_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.stop_sign_overlap_info)
}

// optional .apollo.hdmap.CrosswalkOverlapInfo crosswalk_overlap_info = 6;
inline bool ObjectOverlapInfo::has_crosswalk_overlap_info() const {
  return overlap_info_case() == kCrosswalkOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_crosswalk_overlap_info() {
  _oneof_case_[0] = kCrosswalkOverlapInfo;
}
inline void ObjectOverlapInfo::clear_crosswalk_overlap_info() {
  if (has_crosswalk_overlap_info()) {
    delete overlap_info_.crosswalk_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::apollo::hdmap::CrosswalkOverlapInfo& ObjectOverlapInfo::crosswalk_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  return has_crosswalk_overlap_info()
      ? *overlap_info_.crosswalk_overlap_info_
      : ::apollo::hdmap::CrosswalkOverlapInfo::default_instance();
}
inline ::apollo::hdmap::CrosswalkOverlapInfo* ObjectOverlapInfo::mutable_crosswalk_overlap_info() {
  if (!has_crosswalk_overlap_info()) {
    clear_overlap_info();
    set_has_crosswalk_overlap_info();
    overlap_info_.crosswalk_overlap_info_ = new ::apollo::hdmap::CrosswalkOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  return overlap_info_.crosswalk_overlap_info_;
}
inline ::apollo::hdmap::CrosswalkOverlapInfo* ObjectOverlapInfo::release_crosswalk_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
  if (has_crosswalk_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::CrosswalkOverlapInfo* temp = overlap_info_.crosswalk_overlap_info_;
    overlap_info_.crosswalk_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_crosswalk_overlap_info(::apollo::hdmap::CrosswalkOverlapInfo* crosswalk_overlap_info) {
  clear_overlap_info();
  if (crosswalk_overlap_info) {
    set_has_crosswalk_overlap_info();
    overlap_info_.crosswalk_overlap_info_ = crosswalk_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.crosswalk_overlap_info)
}

// optional .apollo.hdmap.JunctionOverlapInfo junction_overlap_info = 7;
inline bool ObjectOverlapInfo::has_junction_overlap_info() const {
  return overlap_info_case() == kJunctionOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_junction_overlap_info() {
  _oneof_case_[0] = kJunctionOverlapInfo;
}
inline void ObjectOverlapInfo::clear_junction_overlap_info() {
  if (has_junction_overlap_info()) {
    delete overlap_info_.junction_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::apollo::hdmap::JunctionOverlapInfo& ObjectOverlapInfo::junction_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.junction_overlap_info)
  return has_junction_overlap_info()
      ? *overlap_info_.junction_overlap_info_
      : ::apollo::hdmap::JunctionOverlapInfo::default_instance();
}
inline ::apollo::hdmap::JunctionOverlapInfo* ObjectOverlapInfo::mutable_junction_overlap_info() {
  if (!has_junction_overlap_info()) {
    clear_overlap_info();
    set_has_junction_overlap_info();
    overlap_info_.junction_overlap_info_ = new ::apollo::hdmap::JunctionOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.junction_overlap_info)
  return overlap_info_.junction_overlap_info_;
}
inline ::apollo::hdmap::JunctionOverlapInfo* ObjectOverlapInfo::release_junction_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.junction_overlap_info)
  if (has_junction_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::JunctionOverlapInfo* temp = overlap_info_.junction_overlap_info_;
    overlap_info_.junction_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_junction_overlap_info(::apollo::hdmap::JunctionOverlapInfo* junction_overlap_info) {
  clear_overlap_info();
  if (junction_overlap_info) {
    set_has_junction_overlap_info();
    overlap_info_.junction_overlap_info_ = junction_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.junction_overlap_info)
}

// optional .apollo.hdmap.YieldOverlapInfo yield_sign_overlap_info = 8;
inline bool ObjectOverlapInfo::has_yield_sign_overlap_info() const {
  return overlap_info_case() == kYieldSignOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_yield_sign_overlap_info() {
  _oneof_case_[0] = kYieldSignOverlapInfo;
}
inline void ObjectOverlapInfo::clear_yield_sign_overlap_info() {
  if (has_yield_sign_overlap_info()) {
    delete overlap_info_.yield_sign_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::apollo::hdmap::YieldOverlapInfo& ObjectOverlapInfo::yield_sign_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  return has_yield_sign_overlap_info()
      ? *overlap_info_.yield_sign_overlap_info_
      : ::apollo::hdmap::YieldOverlapInfo::default_instance();
}
inline ::apollo::hdmap::YieldOverlapInfo* ObjectOverlapInfo::mutable_yield_sign_overlap_info() {
  if (!has_yield_sign_overlap_info()) {
    clear_overlap_info();
    set_has_yield_sign_overlap_info();
    overlap_info_.yield_sign_overlap_info_ = new ::apollo::hdmap::YieldOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  return overlap_info_.yield_sign_overlap_info_;
}
inline ::apollo::hdmap::YieldOverlapInfo* ObjectOverlapInfo::release_yield_sign_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
  if (has_yield_sign_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::YieldOverlapInfo* temp = overlap_info_.yield_sign_overlap_info_;
    overlap_info_.yield_sign_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_yield_sign_overlap_info(::apollo::hdmap::YieldOverlapInfo* yield_sign_overlap_info) {
  clear_overlap_info();
  if (yield_sign_overlap_info) {
    set_has_yield_sign_overlap_info();
    overlap_info_.yield_sign_overlap_info_ = yield_sign_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.yield_sign_overlap_info)
}

// optional .apollo.hdmap.ClearAreaOverlapInfo clear_area_overlap_info = 9;
inline bool ObjectOverlapInfo::has_clear_area_overlap_info() const {
  return overlap_info_case() == kClearAreaOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_clear_area_overlap_info() {
  _oneof_case_[0] = kClearAreaOverlapInfo;
}
inline void ObjectOverlapInfo::clear_clear_area_overlap_info() {
  if (has_clear_area_overlap_info()) {
    delete overlap_info_.clear_area_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::apollo::hdmap::ClearAreaOverlapInfo& ObjectOverlapInfo::clear_area_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  return has_clear_area_overlap_info()
      ? *overlap_info_.clear_area_overlap_info_
      : ::apollo::hdmap::ClearAreaOverlapInfo::default_instance();
}
inline ::apollo::hdmap::ClearAreaOverlapInfo* ObjectOverlapInfo::mutable_clear_area_overlap_info() {
  if (!has_clear_area_overlap_info()) {
    clear_overlap_info();
    set_has_clear_area_overlap_info();
    overlap_info_.clear_area_overlap_info_ = new ::apollo::hdmap::ClearAreaOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  return overlap_info_.clear_area_overlap_info_;
}
inline ::apollo::hdmap::ClearAreaOverlapInfo* ObjectOverlapInfo::release_clear_area_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
  if (has_clear_area_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::ClearAreaOverlapInfo* temp = overlap_info_.clear_area_overlap_info_;
    overlap_info_.clear_area_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_clear_area_overlap_info(::apollo::hdmap::ClearAreaOverlapInfo* clear_area_overlap_info) {
  clear_overlap_info();
  if (clear_area_overlap_info) {
    set_has_clear_area_overlap_info();
    overlap_info_.clear_area_overlap_info_ = clear_area_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.clear_area_overlap_info)
}

// optional .apollo.hdmap.SpeedBumpOverlapInfo speed_bump_overlap_info = 10;
inline bool ObjectOverlapInfo::has_speed_bump_overlap_info() const {
  return overlap_info_case() == kSpeedBumpOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_speed_bump_overlap_info() {
  _oneof_case_[0] = kSpeedBumpOverlapInfo;
}
inline void ObjectOverlapInfo::clear_speed_bump_overlap_info() {
  if (has_speed_bump_overlap_info()) {
    delete overlap_info_.speed_bump_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::apollo::hdmap::SpeedBumpOverlapInfo& ObjectOverlapInfo::speed_bump_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  return has_speed_bump_overlap_info()
      ? *overlap_info_.speed_bump_overlap_info_
      : ::apollo::hdmap::SpeedBumpOverlapInfo::default_instance();
}
inline ::apollo::hdmap::SpeedBumpOverlapInfo* ObjectOverlapInfo::mutable_speed_bump_overlap_info() {
  if (!has_speed_bump_overlap_info()) {
    clear_overlap_info();
    set_has_speed_bump_overlap_info();
    overlap_info_.speed_bump_overlap_info_ = new ::apollo::hdmap::SpeedBumpOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  return overlap_info_.speed_bump_overlap_info_;
}
inline ::apollo::hdmap::SpeedBumpOverlapInfo* ObjectOverlapInfo::release_speed_bump_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
  if (has_speed_bump_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::SpeedBumpOverlapInfo* temp = overlap_info_.speed_bump_overlap_info_;
    overlap_info_.speed_bump_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_speed_bump_overlap_info(::apollo::hdmap::SpeedBumpOverlapInfo* speed_bump_overlap_info) {
  clear_overlap_info();
  if (speed_bump_overlap_info) {
    set_has_speed_bump_overlap_info();
    overlap_info_.speed_bump_overlap_info_ = speed_bump_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.speed_bump_overlap_info)
}

// optional .apollo.hdmap.ParkingSpaceOverlapInfo parking_space_overlap_info = 11;
inline bool ObjectOverlapInfo::has_parking_space_overlap_info() const {
  return overlap_info_case() == kParkingSpaceOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_parking_space_overlap_info() {
  _oneof_case_[0] = kParkingSpaceOverlapInfo;
}
inline void ObjectOverlapInfo::clear_parking_space_overlap_info() {
  if (has_parking_space_overlap_info()) {
    delete overlap_info_.parking_space_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::apollo::hdmap::ParkingSpaceOverlapInfo& ObjectOverlapInfo::parking_space_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  return has_parking_space_overlap_info()
      ? *overlap_info_.parking_space_overlap_info_
      : ::apollo::hdmap::ParkingSpaceOverlapInfo::default_instance();
}
inline ::apollo::hdmap::ParkingSpaceOverlapInfo* ObjectOverlapInfo::mutable_parking_space_overlap_info() {
  if (!has_parking_space_overlap_info()) {
    clear_overlap_info();
    set_has_parking_space_overlap_info();
    overlap_info_.parking_space_overlap_info_ = new ::apollo::hdmap::ParkingSpaceOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  return overlap_info_.parking_space_overlap_info_;
}
inline ::apollo::hdmap::ParkingSpaceOverlapInfo* ObjectOverlapInfo::release_parking_space_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
  if (has_parking_space_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::ParkingSpaceOverlapInfo* temp = overlap_info_.parking_space_overlap_info_;
    overlap_info_.parking_space_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_parking_space_overlap_info(::apollo::hdmap::ParkingSpaceOverlapInfo* parking_space_overlap_info) {
  clear_overlap_info();
  if (parking_space_overlap_info) {
    set_has_parking_space_overlap_info();
    overlap_info_.parking_space_overlap_info_ = parking_space_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.parking_space_overlap_info)
}

// optional .apollo.hdmap.PNCJunctionOverlapInfo pnc_junction_overlap_info = 12;
inline bool ObjectOverlapInfo::has_pnc_junction_overlap_info() const {
  return overlap_info_case() == kPncJunctionOverlapInfo;
}
inline void ObjectOverlapInfo::set_has_pnc_junction_overlap_info() {
  _oneof_case_[0] = kPncJunctionOverlapInfo;
}
inline void ObjectOverlapInfo::clear_pnc_junction_overlap_info() {
  if (has_pnc_junction_overlap_info()) {
    delete overlap_info_.pnc_junction_overlap_info_;
    clear_has_overlap_info();
  }
}
inline  const ::apollo::hdmap::PNCJunctionOverlapInfo& ObjectOverlapInfo::pnc_junction_overlap_info() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.ObjectOverlapInfo.pnc_junction_overlap_info)
  return has_pnc_junction_overlap_info()
      ? *overlap_info_.pnc_junction_overlap_info_
      : ::apollo::hdmap::PNCJunctionOverlapInfo::default_instance();
}
inline ::apollo::hdmap::PNCJunctionOverlapInfo* ObjectOverlapInfo::mutable_pnc_junction_overlap_info() {
  if (!has_pnc_junction_overlap_info()) {
    clear_overlap_info();
    set_has_pnc_junction_overlap_info();
    overlap_info_.pnc_junction_overlap_info_ = new ::apollo::hdmap::PNCJunctionOverlapInfo;
  }
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.ObjectOverlapInfo.pnc_junction_overlap_info)
  return overlap_info_.pnc_junction_overlap_info_;
}
inline ::apollo::hdmap::PNCJunctionOverlapInfo* ObjectOverlapInfo::release_pnc_junction_overlap_info() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.ObjectOverlapInfo.pnc_junction_overlap_info)
  if (has_pnc_junction_overlap_info()) {
    clear_has_overlap_info();
    ::apollo::hdmap::PNCJunctionOverlapInfo* temp = overlap_info_.pnc_junction_overlap_info_;
    overlap_info_.pnc_junction_overlap_info_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void ObjectOverlapInfo::set_allocated_pnc_junction_overlap_info(::apollo::hdmap::PNCJunctionOverlapInfo* pnc_junction_overlap_info) {
  clear_overlap_info();
  if (pnc_junction_overlap_info) {
    set_has_pnc_junction_overlap_info();
    overlap_info_.pnc_junction_overlap_info_ = pnc_junction_overlap_info;
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.ObjectOverlapInfo.pnc_junction_overlap_info)
}

inline bool ObjectOverlapInfo::has_overlap_info() const {
  return overlap_info_case() != OVERLAP_INFO_NOT_SET;
}
inline void ObjectOverlapInfo::clear_has_overlap_info() {
  _oneof_case_[0] = OVERLAP_INFO_NOT_SET;
}
inline ObjectOverlapInfo::OverlapInfoCase ObjectOverlapInfo::overlap_info_case() const {
  return ObjectOverlapInfo::OverlapInfoCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Overlap

// optional .apollo.hdmap.Id id = 1;
inline bool Overlap::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Overlap::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Overlap::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Overlap::clear_id() {
  if (id_ != NULL) id_->::apollo::hdmap::Id::Clear();
  clear_has_id();
}
inline const ::apollo::hdmap::Id& Overlap::id() const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.Overlap.id)
  return id_ != NULL ? *id_ : *default_instance_->id_;
}
inline ::apollo::hdmap::Id* Overlap::mutable_id() {
  set_has_id();
  if (id_ == NULL) {
    id_ = new ::apollo::hdmap::Id;
  }
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.Overlap.id)
  return id_;
}
inline ::apollo::hdmap::Id* Overlap::release_id() {
  // @@protoc_insertion_point(field_release:apollo.hdmap.Overlap.id)
  clear_has_id();
  ::apollo::hdmap::Id* temp = id_;
  id_ = NULL;
  return temp;
}
inline void Overlap::set_allocated_id(::apollo::hdmap::Id* id) {
  delete id_;
  id_ = id;
  if (id) {
    set_has_id();
  } else {
    clear_has_id();
  }
  // @@protoc_insertion_point(field_set_allocated:apollo.hdmap.Overlap.id)
}

// repeated .apollo.hdmap.ObjectOverlapInfo object = 2;
inline int Overlap::object_size() const {
  return object_.size();
}
inline void Overlap::clear_object() {
  object_.Clear();
}
inline const ::apollo::hdmap::ObjectOverlapInfo& Overlap::object(int index) const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.Overlap.object)
  return object_.Get(index);
}
inline ::apollo::hdmap::ObjectOverlapInfo* Overlap::mutable_object(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.Overlap.object)
  return object_.Mutable(index);
}
inline ::apollo::hdmap::ObjectOverlapInfo* Overlap::add_object() {
  // @@protoc_insertion_point(field_add:apollo.hdmap.Overlap.object)
  return object_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::ObjectOverlapInfo >*
Overlap::mutable_object() {
  // @@protoc_insertion_point(field_mutable_list:apollo.hdmap.Overlap.object)
  return &object_;
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::ObjectOverlapInfo >&
Overlap::object() const {
  // @@protoc_insertion_point(field_list:apollo.hdmap.Overlap.object)
  return object_;
}

// repeated .apollo.hdmap.RegionOverlapInfo region_overlap = 3;
inline int Overlap::region_overlap_size() const {
  return region_overlap_.size();
}
inline void Overlap::clear_region_overlap() {
  region_overlap_.Clear();
}
inline const ::apollo::hdmap::RegionOverlapInfo& Overlap::region_overlap(int index) const {
  // @@protoc_insertion_point(field_get:apollo.hdmap.Overlap.region_overlap)
  return region_overlap_.Get(index);
}
inline ::apollo::hdmap::RegionOverlapInfo* Overlap::mutable_region_overlap(int index) {
  // @@protoc_insertion_point(field_mutable:apollo.hdmap.Overlap.region_overlap)
  return region_overlap_.Mutable(index);
}
inline ::apollo::hdmap::RegionOverlapInfo* Overlap::add_region_overlap() {
  // @@protoc_insertion_point(field_add:apollo.hdmap.Overlap.region_overlap)
  return region_overlap_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::RegionOverlapInfo >*
Overlap::mutable_region_overlap() {
  // @@protoc_insertion_point(field_mutable_list:apollo.hdmap.Overlap.region_overlap)
  return &region_overlap_;
}
inline const ::google::protobuf::RepeatedPtrField< ::apollo::hdmap::RegionOverlapInfo >&
Overlap::region_overlap() const {
  // @@protoc_insertion_point(field_list:apollo.hdmap.Overlap.region_overlap)
  return region_overlap_;
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace hdmap
}  // namespace apollo

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_modules_2fmap_2fproto_2fmap_5foverlap_2eproto__INCLUDED
